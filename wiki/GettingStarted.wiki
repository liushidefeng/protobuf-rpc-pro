= Getting Started =

The [http://protobuf-rpc-pro.googlecode.com/svn/trunk/protobuf-rpc-pro-duplex/src/test/java/com/googlecode/protobuf/pro/duplex/example example] source package contains several runnable examples. 

The examples use a simple [http://protobuf-rpc-pro.googlecode.com/svn/trunk/protobuf-rpc-pro-duplex/src/test/protos/pingpong.proto PingPong] service where a client can call "ping" on a server.

= Client Code =

Firstly we declare who the client is and who the server is that we're going to connect to. Note that the client does not actually bind to port 1234, it is just used as a "name".
{{{
	PeerInfo client = new PeerInfo("clientHostname", 1234);
	PeerInfo server = new PeerInfo("serverHostname", 8080);
}}}
The main client class to start with is a DuplexTcpClientBootstrap. Netty practitioners will know all about this. Through it you can configure all relevant Socket options like buffer sizes, no delay etc. 
If a client is also going to be acting as a server, it is necessary to setup an RpcCallExecutor who's purpose it is to run the calls ( using threads separate from the IO Threads ).
{{{    	
    	ThreadPoolCallExecutor executor = new ThreadPoolCallExecutor(3, 10);

    	DuplexTcpClientBootstrap bootstrap = new DuplexTcpClientBootstrap(
        		client, 
        		new NioClientSocketChannelFactory(
                Executors.newCachedThreadPool(),
                Executors.newCachedThreadPool()),
                executor);
}}}
In order to customize TCP settings, you can use all Netty socket options and the "connectResponseTimeoutMillis" which is introduced to put an upper bound on the "peering" time.
{{{
    	bootstrap.setOption("connectTimeoutMillis",10000);
        bootstrap.setOption("connectResponseTimeoutMillis",10000);
        bootstrap.setOption("receiveBufferSize", 1048576);
        bootstrap.setOption("tcpNoDelay", false);
}}}
In order to open a TCP connection to the server it is necessary to "peerWith" it. A server will not allow the same client "named" to connect multiple times. ( You can still make more than one connection to the same server from the same "Process", just choose different ports to name them and separate Bootstraps ).
{{{
    	RpcClientChannel channel = bootstrap.peerWith(serverInfo);
}}}
Then you can use the pretty much standard Protocol Buffer services which you have like this.
{{{
	BlockingInterface myService = PingPongService.newBlockingStub(channel);
	RpcController controller = channel.newRpcController();
			
	Ping request = Ping.newBuilder().set....build();
	Pong pong = myService.ping(controller, request);
}}}
The same RpcClientChannel can be used multiple times for calls to the server, using any Service which the server handles. 

In order to service RPC calls on the client side, you just need to register a service implementation with the bootstrap.
{{{
    	bootstrap.getRpcServiceRegistry().registerService(new PingPongServiceImpl());
}}}    	
Service implementations can be added and removed at runtime. Service methods are looked up by "shortname" so the server and client "packaging" need not be identical.

Finally to close the RpcClientChannel so it cannot be used anymore do, call close. On shutdown of the client application you need to call release resources to stop the low-level IO-Threads.
{{{
	channel.close();
	bootstrap.releaseExternalResources();
}}}
	

== Runtime Dependencies ==
The external dependencies have been kept to a minimum. Netty and commons logging are the only compile time dependencies. At runtime an additional logging facility is optional. Compiled against java 1.6.

{{{
		<dependency>
			<groupId>com.google.protobuf</groupId>
			<artifactId>protobuf-java</artifactId>
			<version>2.3.0</version>
		</dependency>
		<dependency>
			<groupId>org.jboss.netty</groupId>
			<artifactId>netty</artifactId>
			<version>3.2.1.Final</version>
		</dependency>
		<dependency>
			<groupId>commons-logging</groupId>
			<artifactId>commons-logging</artifactId>
			<version>1.1.1</version>
		</dependency>
}}}